
@inproceedings{frandsen_what_1991,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {What is an efficient implementation of the λ-calculus?},
	isbn = {978-3-540-47599-6},
	doi = {10.1007/3540543961_14},
	abstract = {We propose to measure the efficiency of any implementation of the λ-calculus as a function of a new parameter v, that is itself a function of any λ-expression.},
	language = {en},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer},
	author = {Frandsen, Gudmund S. and Sturtivant, Carl},
	editor = {Hughes, John},
	year = {1991},
	keywords = {Input Size, Normal Form, Normal Order, Recursive Function, Turing Machine},
	pages = {289--312},
	file = {Full Text PDF:/home/daan/Zotero/storage/R9G9HDER/Frandsen and Sturtivant - 1991 - What is an efficient implementation of the λ-calcu.pdf:application/pdf},
}

@inproceedings{accattoli_fresh_2019,
	address = {Dagstuhl, Germany},
	series = {Leibniz {International} {Proceedings} in {Informatics} ({LIPIcs})},
	title = {A {Fresh} {Look} at the lambda-{Calculus} ({Invited} {Talk})},
	volume = {131},
	isbn = {978-3-95977-107-8},
	url = {http://drops.dagstuhl.de/opus/volltexte/2019/10508},
	doi = {10.4230/LIPIcs.FSCD.2019.1},
	urldate = {2022-11-16},
	booktitle = {4th {International} {Conference} on {Formal} {Structures} for {Computation} and {Deduction} ({FSCD} 2019)},
	publisher = {Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik},
	author = {Accattoli, Beniamino},
	editor = {Geuvers, Herman},
	year = {2019},
	note = {ISSN: 1868-8969},
	keywords = {abstract machines, lambda-calculus, rewriting, sharing, type systems},
	pages = {1:1--1:20},
	file = {Full Text PDF:/home/daan/Zotero/storage/DPXHAFZS/Accattoli - 2019 - A Fresh Look at the lambda-Calculus (Invited Talk).pdf:application/pdf;Snapshot:/home/daan/Zotero/storage/9TTS9784/10508.html:text/html},
}

@misc{bhat_lambda_2022,
	title = {Lambda the {Ultimate} {SSA}: {Optimizing} {Functional} {Programs} in {SSA}},
	shorttitle = {Lambda the {Ultimate} {SSA}},
	url = {http://arxiv.org/abs/2201.07272},
	doi = {10.48550/arXiv.2201.07272},
	abstract = {Static Single Assignment (SSA) is the workhorse of modern optimizing compilers for imperative programming languages. However, functional languages have been slow to adopt SSA and prefer to use intermediate representations based on minimal lambda calculi due to SSA's inability to express higher order constructs. We exploit a new SSA construct -- regions -- in order to express functional optimizations via classical SSA based reasoning. Region optimization currently relies on ad-hoc analyses and transformations on imperative programs. These ad-hoc transformations are sufficient for imperative languages as regions are used in a limited fashion. In contrast, we use regions pervasively to model sub-expressions in our functional IR. This motivates us to systematize region optimizations. We extend classical SSA reasoning to regions for functional-style analyses and transformations. We implement a new SSA+regions based backend for LEAN4, a theorem prover that implements a purely functional, dependently typed programming language. Our backend is feature-complete and handles all constructs of LEAN4's functional intermediate representation \{{\textbackslash}lambda\}rc within the SSA framework. We evaluate our proposed region optimizations by optimizing \{{\textbackslash}lambda\}rc within an SSA+regions based framework implemented in MLIR and demonstrating performance parity with the current LEAN4 backend. We believe our work will pave the way for a unified optimization framework capable of representing, analyzing, and optimizing both functional and imperative languages.},
	urldate = {2022-11-16},
	publisher = {arXiv},
	author = {Bhat, Siddharth and Grosser, Tobias},
	month = jan,
	year = {2022},
	note = {arXiv:2201.07272 [cs]},
	keywords = {Computer Science - Programming Languages, D.3},
	file = {arXiv Fulltext PDF:/home/daan/Zotero/storage/G4R73RR2/Bhat and Grosser - 2022 - Lambda the Ultimate SSA Optimizing Functional Pro.pdf:application/pdf;arXiv.org Snapshot:/home/daan/Zotero/storage/PGNTMY6Z/2201.html:text/html},
}

@article{fernandez_lambda-calculus_2005,
	title = {Lambda-{Calculus} with {Director} {Strings}},
	volume = {15},
	issn = {1432-0622},
	url = {https://doi.org/10.1007/s00200-005-0169-9},
	doi = {10.1007/s00200-005-0169-9},
	abstract = {We present a name free λ-calculus with explicit substitutions, based on a generalised notion of director strings. Terms are annotated with information – directors – that indicate how substitutions should be propagated. We first present a calculus where we can simulate arbitrary β-reduction steps, and then simplify the rules to model the evaluation of functional programs (reduction to weak head normal form). We also show that we can define the closed reduction strategy. This is a weak strategy which, in contrast with standard weak strategies, allows certain reductions to take place inside λ-abstractions thus offering more sharing. Our experimental results confirm that, for large combinator-based terms, our weak evaluation strategies out-perform standard evaluators. Moreover, we derive two abstract machines for strong reduction which inherit the efficiency of the weak evaluators.},
	language = {en},
	number = {6},
	urldate = {2022-11-16},
	journal = {Applicable Algebra in Engineering, Communication and Computing},
	author = {Fernández, Maribel and Mackie, Ian and Sinot, François-Régis},
	month = apr,
	year = {2005},
	keywords = {Director Strings, Explicit Substitutions, Strategies, λ-Calculus},
	pages = {393--437},
	file = {Full Text PDF:/home/daan/Zotero/storage/QEPRKQJW/Fernández et al. - 2005 - Lambda-Calculus with Director Strings.pdf:application/pdf},
}

@inproceedings{hammes_performance_1997,
	title = {On the {Performance} of {Functional} {Programming} {Languages} on {Realistic} {Benchmarks}.},
	author = {Hammes, Jeffrey and Böhm, A.},
	month = jan,
	year = {1997},
	pages = {296--304},
	file = {Full Text PDF:/home/daan/Zotero/storage/4IKJLYPA/Hammes and Böhm - 1997 - On the Performance of Functional Programming Langu.pdf:application/pdf},
}

@article{hartel_benchmarking_1996,
	title = {Benchmarking implementations of functional languages with ‘{Pseudoknot}’, a float-intensive benchmark},
	volume = {6},
	issn = {1469-7653, 0956-7968},
	url = {http://www.cambridge.org/core/journals/journal-of-functional-programming/article/benchmarking-implementations-of-functional-languages-with-pseudoknot-a-float-intensive-benchmark/39682AA1BC05B5F1C511BB939839F158},
	doi = {10.1017/S0956796800001891},
	abstract = {Over 25 implementations of different functional languages are benchmarked using the same program, a floating-point intensive application taken from molecular biology. The principal aspects studied are compile time and execution time for the various implementations that were benchmarked. An important consideration is how the program can be modified and tuned to obtain maximal performance on each language implementation. With few exceptions, the compilers take a significant amount of time to compile this program, though most compilers were faster than the then current GNU C compiler (GCC version 2.5.8). Compilers that generate C or Lisp are often slower than those that generate native code directly: the cost of compiling the intermediate form is normally a large fraction of the total compilation time. There is no clear distinction between the runtime performance of eager and lazy implementations when appropriate annotations are used: lazy implementations have clearly come of age when it comes to implementing largely strict applications, such as the Pseudoknot program. The speed of C can be approached by some implementations, but to achieve this performance, special measures such as strictness annotations are required by non-strict implementations. The benchmark results have to be interpreted with care. Firstly, a benchmark based on a single program cannot cover a wide spectrum of ‘typical’ applications. Secondly, the compilers vary in the kind and level of optimisations offered, so the effort required to obtain an optimal version of the program is similarly varied.},
	language = {en},
	number = {4},
	urldate = {2022-11-16},
	journal = {Journal of Functional Programming},
	author = {Hartel, Pieter H. and Feeley, Marc and Alt, Martin and Augustsson, Lennart and Baumann, Peter and Beemster, Marcel and Chailloux, Emmanuel and Flood, Christine H. and Grieskamp, Wolfgang and Groningen, John H. G. Van and Hammond, Kevin and Hausman, Bogumil and Ivory, Melody Y. and Jones, Richard E. and Kamperman, Jasper and Lee, Peter and Leroy, Xavier and Lins, Rafael D. and Loosemore, Sandra and Röjemo, Niklas and Serrano, Manuel and Talpin, Jean-Pierre and Thackray, Jon and Thomas, Stephen and Walters, Pum and Weis, Pierre and Wentworth, Peter},
	month = jul,
	year = {1996},
	note = {Publisher: Cambridge University Press},
	pages = {621--655},
	file = {Full Text PDF:/home/daan/Zotero/storage/8I7HT5M6/Hartel et al. - 1996 - Benchmarking implementations of functional languag.pdf:application/pdf;Snapshot:/home/daan/Zotero/storage/4TXRBGX3/39682AA1BC05B5F1C511BB939839F158.html:text/html},
}

@inproceedings{marlow_making_2004,
	address = {New York, NY, USA},
	series = {{ICFP} '04},
	title = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
	isbn = {978-1-58113-905-1},
	shorttitle = {Making a fast curry},
	url = {http://doi.org/10.1145/1016850.1016856},
	doi = {10.1145/1016850.1016856},
	abstract = {Higher-order languages that encourage currying are implemented using one of two basic evaluation models: push/enter or eval/apply. Implementors use their intuition and qualitative judgements to choose one model or the other.Our goal in this paper is to provide, for the first time, a more substantial basis for this choice, based on our qualitative and quantitative experience of implementing both models in a state-of-the-art compiler for Haskell.Our conclusion is simple, and contradicts our initial intuition: compiled implementations should use eval/apply.},
	urldate = {2022-11-16},
	booktitle = {Proceedings of the ninth {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {Association for Computing Machinery},
	author = {Marlow, Simon and Jones, Simon Peyton},
	month = sep,
	year = {2004},
	pages = {4--15},
	file = {Full Text PDF:/home/daan/Zotero/storage/CM66KTMX/Marlow and Jones - 2004 - Making a fast curry pushenter vs. evalapply for.pdf:application/pdf},
}

@inproceedings{reich_lazy_2012,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Lazy {Generation} of {Canonical} {Test} {Programs}},
	isbn = {978-3-642-34407-7},
	doi = {10.1007/978-3-642-34407-7_5},
	abstract = {Property-based testing can be a highly effective form of lightweight verification, but it relies critically on the method used to generate test cases. If we wish to test properties of compilers and related tools we need a generator for source programs as test cases.},
	language = {en},
	booktitle = {Implementation and {Application} of {Functional} {Languages}},
	publisher = {Springer},
	author = {Reich, Jason S. and Naylor, Matthew and Runciman, Colin},
	editor = {Gill, Andy and Hage, Jurriaan},
	year = {2012},
	keywords = {automated testing, compiler correctness, lightweight verification, search-based software engineering, Small Check},
	pages = {69--84},
	file = {Full Text PDF:/home/daan/Zotero/storage/GYEH2VTU/Reich et al. - 2012 - Lazy Generation of Canonical Test Programs.pdf:application/pdf},
}

@inproceedings{partain_nofib_1993,
	address = {London},
	series = {Workshops in {Computing}},
	title = {The nofib {Benchmark} {Suite} of {Haskell} {Programs}},
	isbn = {978-1-4471-3215-8},
	doi = {10.1007/978-1-4471-3215-8_17},
	abstract = {This position paper describes the need for, make-up of, and “rules of the game” for a benchmark suite of Haskell programs. (It does not include results from running the suite.) Those of us working on the Glasgow Haskell compiler hope this suite will encourage sound, quantitative assessment of lazy functional programming systems. This version of this paper reflects the state of play at the initial pre-release of the suite.},
	language = {en},
	booktitle = {Functional {Programming}, {Glasgow} 1992},
	publisher = {Springer},
	author = {Partain, Will},
	editor = {Launchbury, John and Sansom, Patrick},
	year = {1993},
	keywords = {Benchmark Program, Benchmark Suite, Computer Architecture, Functional Programming, Real Program},
	pages = {195--202},
}

@article{vollmer_sc-haskell_2017,
	title = {{SC}-{Haskell}: {Sequential} {Consistency} in {Languages} {That} {Minimize} {Mutable} {Shared} {Heap}},
	volume = {52},
	issn = {0362-1340},
	shorttitle = {{SC}-{Haskell}},
	url = {http://doi.org/10.1145/3155284.3018746},
	doi = {10.1145/3155284.3018746},
	abstract = {A core, but often neglected, aspect of a programming language design is its memory (consistency) model. Sequential consistency{\textasciitilde}(SC) is the most intuitive memory model for programmers as it guarantees sequential composition of instructions and provides a simple abstraction of shared memory as a single global store with atomic read and writes. Unfortunately, SC is widely considered to be impractical due to its associated performance overheads. Perhaps contrary to popular opinion, this paper demonstrates that SC is achievable with acceptable performance overheads for mainstream languages that minimize mutable shared heap. In particular, we modify the Glasgow Haskell Compiler to insert fences on all writes to shared mutable memory accessed in nonfunctional parts of the program. For a benchmark suite containing 1,279 programs, SC adds a geomean overhead of less than 0.4{\textbackslash}\% on an x86 machine. The efficiency of SC arises primarily due to the isolation provided by the Haskell type system between purely functional and thread-local imperative computations on the one hand, and imperative computations on the global heap on the other. We show how to use new programming idioms to further reduce the SC overhead; these create a virtuous cycle of less overhead and even stronger semantic guarantees (static data-race freedom).},
	number = {8},
	urldate = {2022-11-16},
	journal = {ACM SIGPLAN Notices},
	author = {Vollmer, Michael and Scott, Ryan G. and Musuvathi, Madanlal and Newton, Ryan R.},
	month = jan,
	year = {2017},
	keywords = {functional programming, memory models, sequential consistency},
	pages = {283--298},
	file = {Full Text PDF:/home/daan/Zotero/storage/S8V8LTID/Vollmer et al. - 2017 - SC-Haskell Sequential Consistency in Languages Th.pdf:application/pdf},
}

@article{krivine_call-by-name_2007,
	title = {A call-by-name lambda-calculus machine},
	volume = {20},
	issn = {1573-0557},
	url = {https://doi.org/10.1007/s10990-007-9018-9},
	doi = {10.1007/s10990-007-9018-9},
	abstract = {We present a particularly simple lazy lambda-calculus machine, which was introduced twenty-five years ago. It has been, since, used and implemented by several authors, but remained unpublished. We also build an extension, with a control instruction and continuations. This machine was conceived in order to execute programs obtained from mathematical proofs, by means of the Curry-Howard (also known as “proof-program”) correspondence. The control instruction corresponds to the axiom of excluded middle.},
	language = {en},
	number = {3},
	urldate = {2022-11-16},
	journal = {Higher-Order and Symbolic Computation},
	author = {Krivine, Jean-Louis},
	month = sep,
	year = {2007},
	keywords = {Control instruction, Curry-Howard correspondence, Lambda-calculus machine},
	pages = {199--207},
	file = {Full Text PDF:/home/daan/Zotero/storage/AY38DLKU/Krivine - 2007 - A call-by-name lambda-calculus machine.pdf:application/pdf},
}

@article{terei_low_nodate,
	title = {Low {Level} {Virtual} {Machine} for {Glasgow} {Haskell} {Compiler}},
	language = {en},
	author = {Terei, David Anthony},
	pages = {73},
	file = {Terei - Low Level Virtual Machine for Glasgow Haskell Comp.pdf:/home/daan/Zotero/storage/SCEV5V4N/Terei - Low Level Virtual Machine for Glasgow Haskell Comp.pdf:application/pdf},
}

@misc{nph_implement_2021,
	type = {Forum post},
	title = {Implement {SKI} combinator calculus},
	url = {https://codegolf.stackexchange.com/q/205809},
	urldate = {2022-11-23},
	journal = {Code Golf Stack Exchange},
	author = {nph},
	month = jun,
	year = {2021},
	file = {Snapshot:/home/daan/Zotero/storage/TU9BRZMX/implement-ski-combinator-calculus.html:text/html},
}

@misc{burrows_combinator_2009,
	title = {A {Combinator} {Processor}},
	url = {https://q4.github.io/dissertations/eb379.pdf},
	urldate = {2022-11-23},
	author = {Burrows, Emma},
	year = {2009},
	file = {A Combinator Processor:/home/daan/Zotero/storage/YSNFMA8Q/eb379.pdf:application/pdf},
}

@incollection{koopman_appendix_1990,
	title = {Appendix {A} - {A} {Tutorial} on {Combinator} {Graph} {Reduction}},
	isbn = {978-0-12-419240-9},
	url = {https://www.sciencedirect.com/science/article/pii/B978012419240950015X},
	language = {en},
	urldate = {2022-11-23},
	booktitle = {An {Architecture} for {Combinator} {Graph} {Reduction}},
	publisher = {Academic Press},
	editor = {Koopman, Philip John},
	month = jan,
	year = {1990},
	doi = {10.1016/B978-0-12-419240-9.50015-X},
	pages = {101--122},
	file = {Koopman - 1990 - Appendix A - A Tutorial on Combinator Graph Reduct.pdf:/home/daan/Zotero/storage/9MHYB7JR/Koopman - 1990 - Appendix A - A Tutorial on Combinator Graph Reduct.pdf:application/pdf;ScienceDirect Snapshot:/home/daan/Zotero/storage/UG4F525U/B978012419240950015X.html:text/html},
}

@article{cavusoglu_template_2002,
	title = {A {Template} {Based} {Graph} {Reduction} {System} {Based} on {Combinators}},
	volume = {7},
	copyright = {http://creativecommons.org/licenses/by/3.0/},
	issn = {2297-8747},
	url = {https://www.mdpi.com/2297-8747/7/3/253},
	doi = {10.3390/mca7030253},
	abstract = {Graph reduction is one of the important evaluation strategy for lazy functional Programming. A combinator is a function that contains no free variables. The idea is based on the fact that, all of the variables in a program can be removed by transforming it into a sequence of combinators which would be drawn from a small pre-defined (fixed) set of combinators (SKI), or which would be drawn from an unlimited number of non-pre- defined set of dynamic super-combinators (SC). We are suggesting a template based algorithm which reduces the stored graph structure of the super-combinators. We can define any produced super-combinators by using templates and use them to perform reduction on the graph. The template based algorithrn could be extended and any produced super-combinators can be defined with a predefined template list. The test results show that our approach increases the efficiency of super-combinators algorithms.},
	language = {en},
	number = {3},
	urldate = {2022-11-23},
	journal = {Mathematical and Computational Applications},
	author = {Çavuşoğlu, Abdullah and Göktaş, H. Haldun and Vardal, Necla},
	month = dec,
	year = {2002},
	note = {Number: 3
Publisher: Association for Scientific Research},
	keywords = {Abstract Programming, Combinators, Graph Reduction},
	pages = {253--262},
	file = {Full Text PDF:/home/daan/Zotero/storage/TD5YMX78/Çavuşoğlu et al. - 2002 - A Template Based Graph Reduction System Based on C.pdf:application/pdf;Snapshot:/home/daan/Zotero/storage/U3X6R9QU/253.html:text/html},
}

@misc{koopman_architecture_1992,
	title = {An {Architecture} for {Combinator} {Graph} {Reduction} ({TIGRE})},
	url = {http://users.ece.cmu.edu/~koopman/tigre/},
	urldate = {2022-11-23},
	author = {Koopman, Philip},
	year = {1992},
	file = {An Architecture for Combinator Graph Reduction (TIGRE):/home/daan/Zotero/storage/ZIMKXZ3Q/tigre.html:text/html},
}

@article{chen_priority_2007,
	title = {Priority {Queues} and {Dijkstra}’s {Algorithm}},
	abstract = {We study the impact of using diﬀerent priority queues in the performance of Dijkstra’s SSSP algorithm. We consider only general priority queues that can handle any type of keys (integer, ﬂoating point, etc.); the only exception is that we use as a benchmark the DIMACS Challenge SSSP code [1] which can handle only integer values for distances.},
	language = {en},
	author = {Chen, Mo and Chowdhury, Rezaul Alam and Ramachandran, Vijaya and Roche, David Lan and Tong, Lingling},
	month = oct,
	year = {2007},
	pages = {25},
	file = {Chen et al. - Priority Queues and Dijkstra’s Algorithm.pdf:/home/daan/Zotero/storage/PKRLN3TU/Chen et al. - Priority Queues and Dijkstra’s Algorithm.pdf:application/pdf},
}

@article{hartel_performance_1991,
	title = {Performance of lazy combinator graph reduction},
	volume = {21},
	issn = {1097-024X},
	url = {http://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380210306},
	doi = {10.1002/spe.4380210306},
	abstract = {The performance of program-derived combinator graph reduction is known to be superior to that of graph reduction based on a fixed set of standard combinators. The major advantage of program-derived combinator reduction is that it uses less transient store than standard combinator reduction. We show on what activities a combinator reduction algorithm spends its execution time. Based on this analysis we show that it depends to a large extent on the application how much faster a program will run if program-derived combinators are used instead of standard combinators. The analysis is based on experimental evidence obtained from a small bench-mark of medium-size functional programs. Performance gains of up to 11 x are reported for target architectures on which each memory reference consumes one unit of time. The results are valid for implementations of combinator graph reduction that use binary graphs.},
	language = {en},
	number = {3},
	urldate = {2022-11-26},
	journal = {Software: Practice and Experience},
	author = {Hartel, Pieter H.},
	year = {1991},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.4380210306},
	keywords = {G-machine, Graph reduction, Instruction level timing, Performance modelling, Small functional bench-mark, Turner's combinators},
	pages = {299--329},
	file = {Full Text PDF:/home/daan/Zotero/storage/WT555Q3G/Hartel - 1991 - Performance of lazy combinator graph reduction.pdf:application/pdf;Snapshot:/home/daan/Zotero/storage/UP9EAMV9/spe.html:text/html},
}

@article{turner_new_1979,
	title = {A new implementation technique for applicative languages},
	volume = {9},
	issn = {1097-024X},
	url = {http://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380090105},
	doi = {10.1002/spe.4380090105},
	abstract = {It is shown how by using results from combinatory logic an applicative language, such as LISP, can be translated into a form from which all bound variables have been removed. A machine is described which can efficiently execute the resulting code. This implementation is compared with a conventional interpreter and found to have a number of advantages. Of these the most important is that programs which exploit higher order functions to achieve great compactness of expression are executed much more efficiently.},
	language = {en},
	number = {1},
	urldate = {2022-11-26},
	journal = {Software: Practice and Experience},
	author = {Turner, D. A.},
	year = {1979},
	note = {\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.4380090105},
	keywords = {Combinators, Applicative languages, Bracket abstraction, Lazy evaluation, Normal graph reduction, Substitution machine},
	pages = {31--49},
	file = {Full Text PDF:/home/daan/Zotero/storage/KD49EX5R/Turner - 1979 - A new implementation technique for applicative lan.pdf:application/pdf;Snapshot:/home/daan/Zotero/storage/XNUUJAME/spe.html:text/html},
}

@inproceedings{turner_miranda_1985,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Miranda: {A} non-strict functional language with polymorphic types},
	isbn = {978-3-540-39677-2},
	shorttitle = {Miranda},
	doi = {10.1007/3-540-15975-4_26},
	language = {en},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer},
	author = {Turner, D. A.},
	editor = {Jouannaud, Jean-Pierre},
	year = {1985},
	keywords = {Functional Programming, Abstract Data Type, Abstract Type, Data Type, Free Algebra},
	pages = {1--16},
	file = {Full Text PDF:/home/daan/Zotero/storage/CUQG5AVA/Turner - 1985 - Miranda A non-strict functional language with pol.pdf:application/pdf},
}

@inproceedings{scheevel_norma_1986,
	address = {New York, NY, USA},
	series = {{LFP} '86},
	title = {{NORMA}: a graph reduction processor},
	isbn = {978-0-89791-200-6},
	shorttitle = {{NORMA}},
	url = {https://doi.org/10.1145/319838.319864},
	doi = {10.1145/319838.319864},
	urldate = {2022-11-26},
	booktitle = {Proceedings of the 1986 {ACM} conference on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Scheevel, Mark},
	month = aug,
	year = {1986},
	pages = {212--219},
	file = {Full Text PDF:/home/daan/Zotero/storage/QP2YJS37/Scheevel - 1986 - NORMA a graph reduction processor.pdf:application/pdf},
}

@inproceedings{clarke_skim_1980,
	address = {New York, NY, USA},
	series = {{LFP} '80},
	title = {{SKIM} - {The} {S}, {K}, {I} reduction machine},
	isbn = {978-1-4503-7396-8},
	url = {http://doi.org/10.1145/800087.802798},
	doi = {10.1145/800087.802798},
	abstract = {SKIM is a computer built to explore pure functional programming, combinators as a machine language and the use of hardware to provide direct support for a high level language. Its design stresses simplicity and aims at providing minicomputer performance (in its particular application areas) for microcomputer costs. This paper discusses the high level reduction language that SKIM supports, the way in which this language is compiled into combinators and the hardware and microcode that then evaluate programs.},
	urldate = {2022-11-26},
	booktitle = {Proceedings of the 1980 {ACM} conference on {LISP} and functional programming},
	publisher = {Association for Computing Machinery},
	author = {Clarke, T. J.W. and Gladstone, P. J.S. and MacLean, C. D. and Norman, A. C.},
	month = aug,
	year = {1980},
	pages = {128--135},
	file = {Full Text PDF:/home/daan/Zotero/storage/KNUVIBJ8/Clarke et al. - 1980 - SKIM - The S, K, I reduction machine.pdf:application/pdf},
}

@inproceedings{kiselyov_lambda_2018,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {lambda to {SKI}, {Semantically}},
	isbn = {978-3-319-90686-7},
	doi = {10.1007/978-3-319-90686-7_3},
	abstract = {We present a technique for compiling lambda-calculus expressions into SKI combinators. Unlike the well-known bracket abstraction based on (syntactic) term re-writing, our algorithm relies on a specially chosen, compositional semantic model of generally open lambda terms. The meaning of a closed lambda term is the corresponding SKI combination. For simply-typed as well as unityped terms, the meaning derivation mirrors the typing derivation. One may also view the algorithm as an algebra, or a non-standard evaluator for lambda-terms (i.e., denotational semantics).},
	language = {en},
	booktitle = {Functional and {Logic} {Programming}},
	publisher = {Springer International Publishing},
	author = {Kiselyov, Oleg},
	editor = {Gallagher, John P. and Sulzmann, Martin},
	year = {2018},
	pages = {33--50},
	file = {Full Text PDF:/home/daan/Zotero/storage/2T2HB37Q/Kiselyov - 2018 - \$\$lambda \$\$to SKI, Semantically.pdf:application/pdf},
}

@misc{noauthor_open_2021,
	title = {Open {Sourcing} {Miranda}},
	url = {http://codesync.global/media/open-sourcing-miranda-david-turner-code-mesh-v-2020-codemeshv2020/},
	language = {en},
	urldate = {2022-12-06},
	journal = {Code Sync},
	month = mar,
	year = {2021},
	file = {Snapshot:/home/daan/Zotero/storage/V6F2YNMJ/open-sourcing-miranda-david-turner-code-mesh-v-2020-codemeshv2020.html:text/html},
}

@article{koopman_cache_1992,
	title = {Cache behavior of combinator graph reduction},
	volume = {14},
	issn = {0164-0925},
	url = {http://doi.org/10.1145/128861.128867},
	doi = {10.1145/128861.128867},
	abstract = {The results of cache-simulation experiments with an abstract machine for reducing combinator graphs are presented. The abstract machine, called TIGRE, exhibits reduction rates that, for similar kinds of combinator graphs on similar kinds of hardware, compare favorably with previously reported techniques. Furthermore, TIGRE maps easily and efficiently onto standard computer architectures, particularly those that allow a restricted form of self-modifying code. This provides some indication that the conventional "stored program" organization of computer systems is not necessarily an inappropriate one for functional programming language implementations. This is not to say, however, that present day computer systems are well equipped to reduce combinator graphs. In particular, the behavior of the cache memory has a significant effect on performance. In order to study and quantify this effect, trace-driven cache simulations of a TIGRE graph reducer running on a reduced instruction-set computer are conducted. The results of these simulations are presented with the following hardware-cache parameters varied: cache size, block size, associativity, memory update policy, and write-allocation policy. To begin with, the cache organization of a commercially available system is used and then the performance sensitivity with respect to variations of each parameter are measured. From the results of the simulation study, a conclusion is made that combinator-graph reduction using TIGRE runs most efficiently when using a cache memory with an allocate-on-write-miss strategy, moderately large block size (preferably with subblock placement), and copy-back memory updates.},
	number = {2},
	urldate = {2022-12-06},
	journal = {ACM Transactions on Programming Languages and Systems},
	author = {Koopman, Philip J. and Lee, Peter and Siewiorek, Daniel P.},
	month = apr,
	year = {1992},
	keywords = {abstract machine, combinators, graph reduction, self-modifying code},
	pages = {265--297},
	file = {Full Text PDF:/home/daan/Zotero/storage/ULNJ9KWC/Koopman et al. - 1992 - Cache behavior of combinator graph reduction.pdf:application/pdf},
}

@inproceedings{kieburtz_g-machine_1985,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The {G}-machine: {A} fast, graph-reduction evaluator},
	isbn = {978-3-540-39677-2},
	shorttitle = {The {G}-machine},
	doi = {10.1007/3-540-15975-4_50},
	abstract = {The G-machine is an abstract architecture for evaluating functional-language programs by programmed graph reduction. Unlike combinator reduction, in which control is derived dynamically from the expression graph itself, control in programmed graph reduction is specified by a sequence of instructions derived by compiling an applicative expression.},
	language = {en},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer},
	author = {Kieburtz, Richard B.},
	editor = {Jouannaud, Jean-Pierre},
	year = {1985},
	keywords = {Graph Reduction, Application Graph, Control Memory, Host Processor, Memory Manager},
	pages = {400--413},
	file = {Full Text PDF:/home/daan/Zotero/storage/CJWRTH55/Kieburtz - 1985 - The G-machine A fast, graph-reduction evaluator.pdf:application/pdf},
}

@inproceedings{fairbairn_tim_1987,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Tim: {A} simple, lazy abstract machine to execute supercombinators},
	isbn = {978-3-540-47879-9},
	shorttitle = {Tim},
	doi = {10.1007/3-540-18317-5_3},
	abstract = {This paper is a description of the three instruction machine Tim, an abstract machine for the execution of supercombinators. Tim usually executes programmes faster than the G-machine style of abstract machine while being at least as easy to implement as an S-K combinator reducer. It has a lower overhead for passing unevaluated arguments than the G-machine, resulting in good performance even without strictness analysis, and is probably easier to implement in hardware.},
	language = {en},
	booktitle = {Functional {Programming} {Languages} and {Computer} {Architecture}},
	publisher = {Springer},
	author = {Fairbairn, Jon and Wray, Stuart},
	editor = {Kahn, Gilles},
	year = {1987},
	keywords = {Abstract Machine, Garbage Collector, Lazy Evaluation, Perfect Code, Shared Application},
	pages = {34--45},
	file = {Full Text PDF:/home/daan/Zotero/storage/KDLTZH92/Fairbairn and Wray - 1987 - Tim A simple, lazy abstract machine to execute su.pdf:application/pdf},
}

@article{burn_spineless_1988,
	title = {The spineless {G}-machine},
	issn = {0-89791-273-X},
	doi = {10.1145/62678.62717},
	abstract = {Recent developments in functional language implementations have resulted in the G-machine, a programmed graph-reduction machine. Taking this as a basis, we introduce an optimised method of performing graph reduction, which does not need to build the spine of the expression being reduced. This Spineless G-machine only updates shared expressions, and then only when they have been reduced to weak head normal form. It is thus more efficient than the standard method of performing graph reduction.
We begin by outlining the philosophy and key features of the Spineless G-machine, and comparing it with the standard G-machine. Simulation results for the two machines are then presented and discussed. The Spineless G-machine is also compared with Tim, giving a series of transformations by which they can be interconverted. These open up a wide design space for abstract graph reduction machines, which was previously unknown. A full specification of the spineless machine is given in the appendix, together with compilation rules for a simple functional language.},
	author = {Burn, G. and Peyton Jones, Simon and Robson, J.},
	month = jan,
	year = {1988},
	pages = {244--258},
	file = {Full Text PDF:/home/daan/Zotero/storage/6FTMRCK6/Burn et al. - 1988 - The spineless G-machine.pdf:application/pdf},
}

@article{jones_implementing_nodate,
	title = {Implementing lazy functional languages on stock hardware: the {Spineless} {Tagless} {G}-machine {Version} 2.5},
	abstract = {The Spineless Tagless G-machine is an abstract machine designed to support nonstrict higher-order functional languages. This presentation of the machine falls into three parts. Firstly, we give a general discussion of the design issues involved in implementing non-strict functional languages. Next, we present the STG , language an austere but recognisably-functional language, which as well as a denotational meaning has a well-de ned operational semantics. The STG language is the {\textbackslash}abstract machine code" for the Spineless Tagless G-machine.},
	language = {en},
	author = {Jones, Simon L Peyton},
	pages = {87},
	file = {Jones - Implementing lazy functional languages on stock ha.pdf:/home/daan/Zotero/storage/IKZVWJV2/Jones - Implementing lazy functional languages on stock ha.pdf:application/pdf},
}

@article{koopman_fresh_1989,
	title = {A fresh look at combinator graph reduction},
	volume = {24},
	issn = {0362-1340},
	url = {http://doi.org/10.1145/74818.74828},
	doi = {10.1145/74818.74828},
	abstract = {We present a new abstract machine for graph reduction called TIGRE. Benchmark results show that TIGRE's execution speed compares quite favorably with previous combinator-graph reduction techniques on similar hardware. Furthermore, the mapping of TIGRE onto conventional hardware is simple and efficient. Mainframe implementations of TIGRE provide performance levels exceeding those previously available on custom graph reduction hardware.},
	number = {7},
	urldate = {2022-12-07},
	journal = {ACM SIGPLAN Notices},
	author = {Koopman, P. J. and Lee, P.},
	month = jun,
	year = {1989},
	pages = {110--119},
	file = {Full Text PDF:/home/daan/Zotero/storage/JG52RDLF/Koopman and Lee - 1989 - A fresh look at combinator graph reduction.pdf:application/pdf},
}

@inproceedings{hudak_history_2007,
	address = {New York, NY, USA},
	series = {{HOPL} {III}},
	title = {A history of {Haskell}: being lazy with class},
	isbn = {978-1-59593-766-7},
	shorttitle = {A history of {Haskell}},
	url = {http://doi.org/10.1145/1238844.1238856},
	doi = {10.1145/1238844.1238856},
	abstract = {This paper describes the history of Haskell, including its genesis and principles, technical contributions, implementations and tools, and applications and impact.},
	urldate = {2022-12-08},
	booktitle = {Proceedings of the third {ACM} {SIGPLAN} conference on {History} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Hudak, Paul and Hughes, John and Peyton Jones, Simon and Wadler, Philip},
	month = jun,
	year = {2007},
	pages = {12--1--12--55},
	file = {Full Text PDF:/home/daan/Zotero/storage/H3CNEB9X/Hudak et al. - 2007 - A history of Haskell being lazy with class.pdf:application/pdf},
}

@article{accetti_structured_2022,
	title = {Structured {Combinators} for {Efficient} {Graph} {Reduction}},
	volume = {21},
	issn = {1556-6064},
	doi = {10.1109/LCA.2022.3198844},
	abstract = {Combinators have a long history in mathematics, logic and computer science, as simple primitive symbols with which complex relationships can be described. In practice, this simplicity comes with a cost, impacting the performance of combinator-based languages and computers. We propose a generalized representation for combinators, not as primitives, but as self-contained definitions, where the structure of their graph-reduction semantics is explicit. For a sample of 798 unique lambda-terms from common benchmark programs, we show that structured combinators can improve the quality of compiled code, generating smaller and more efficient graphs, while translating seamlessly to a machine-friendly encoding, as part of the open-source fun instruction-set architecture.},
	number = {2},
	journal = {IEEE Computer Architecture Letters},
	author = {Accetti, Cecil and Ying, Rendong and Liu, Peilin},
	month = jul,
	year = {2022},
	note = {Conference Name: IEEE Computer Architecture Letters},
	keywords = {Benchmark testing, Resource management, Semantics, Microprocessors, compilers, Applicative (functional) programming, Calculus, instruction set design, Pattern matching, Registers},
	pages = {73--76},
	file = {IEEE Xplore Abstract Record:/home/daan/Zotero/storage/NETGYTM9/9857579.html:text/html;IEEE Xplore Full Text PDF:/home/daan/Zotero/storage/7SXWWAUA/Accetti et al. - 2022 - Structured Combinators for Efficient Graph Reducti.pdf:application/pdf},
}

@article{turner_another_1979,
	title = {Another {Algorithm} for {Bracket} {Abstraction}},
	volume = {44},
	issn = {0022-4812},
	url = {http://www.jstor.org/stable/2273733},
	doi = {10.2307/2273733},
	number = {2},
	urldate = {2022-12-19},
	journal = {The Journal of Symbolic Logic},
	author = {Turner, D. A.},
	year = {1979},
	note = {Publisher: [Association for Symbolic Logic, Cambridge University Press]},
	pages = {267--270},
	file = {JSTOR Full Text PDF:/home/daan/Zotero/storage/3ICML3Q9/Turner - 1979 - Another Algorithm for Bracket Abstraction.pdf:application/pdf},
}

@incollection{akinshin_common_2019,
	address = {Berkeley, CA},
	title = {Common {Benchmarking} {Pitfalls}},
	isbn = {978-1-4842-4941-3},
	url = {https://doi.org/10.1007/978-1-4842-4941-3_2},
	abstract = {In this chapter, we will discuss the most common mistakes that people make when they try to measure performance. If you want to write benchmarks, you have to accept the fact that most of the time you will be wrong. Unfortunately, there is no universally reliable way to verify that you get the performance metrics you wanted to get. There are many pitfalls on different levels: C\# compiler, .NET runtime, CPU, and so on. We will also learn some approaches and techniques to help you to write reliable and correct benchmarks.},
	language = {en},
	urldate = {2023-01-02},
	booktitle = {Pro .{NET} {Benchmarking}: {The} {Art} of {Performance} {Measurement}},
	publisher = {Apress},
	author = {Akinshin, Andrey},
	editor = {Akinshin, Andrey},
	year = {2019},
	doi = {10.1007/978-1-4842-4941-3_2},
	pages = {31--89},
	file = {Full Text PDF:/home/daan/Zotero/storage/FW3ZCTZX/Akinshin - 2019 - Common Benchmarking Pitfalls.pdf:application/pdf},
}

@misc{de_mooij_wx_2015,
	title = {W{\textasciicircum}{X} {JIT}-code enabled in {Firefox}},
	url = {https://jandemooij.nl/blog/wx-jit-code-enabled-in-firefox/},
	urldate = {2023-01-02},
	author = {de Mooij, Jan},
	month = dec,
	year = {2015},
	file = {W^X JIT-code enabled in Firefox:/home/daan/Zotero/storage/Y36LQ2XP/wx-jit-code-enabled-in-firefox.html:text/html},
}

@article{paulson_new_2004,
	title = {New chips stop buffer overflow attacks},
	volume = {37},
	issn = {1558-0814},
	doi = {10.1109/MC.2004.173},
	abstract = {Chip makers are designing a new generation of microprocessors to stop buffer overflow assaults, exploits that hackers often use to attack and extract data from PCs or servers. AMD's Athlon-64 chips for notebook and desktop computers and its Opteron processors for servers include features that provide buffer-overflow protection. Intel offers buffer-overflow protection in its Itanium chips for servers. A buffer overflow occurs when a program or process tries to store more data in a buffer than it was designed to hold. Operating systems that support the buffer-overflow prevention approach mark certain data in memory with a bit that identifies them as executable or nonexecutable. The AMD chips let users turn off the new security feature for legacy programs not written to work with the technology so that the applications can continue to function.},
	number = {10},
	journal = {Computer},
	author = {Paulson, L.D.},
	month = oct,
	year = {2004},
	note = {Conference Name: Computer},
	keywords = {Buffer overflow, Computer aided instruction, Computer hacking, Computer worms, Databases, Electronic mail, Operating systems, Permission, Personal communication networks, Protection},
	pages = {28--},
	file = {IEEE Xplore Abstract Record:/home/daan/Zotero/storage/6RKSAKW9/1350723.html:text/html;IEEE Xplore Full Text PDF:/home/daan/Zotero/storage/CGQ8ABZQ/Paulson - 2004 - New chips stop buffer overflow attacks.pdf:application/pdf},
}
