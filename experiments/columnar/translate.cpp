#include <filesystem>

#include <llvm/Support/CommandLine.h>
#include <llvm/Support/Error.h>
#include <llvm/Support/SourceMgr.h>
#include <mlir/IR/Diagnostics.h>
#include <mlir/IR/Location.h>
#include <mlir/Support/LLVM.h>
#include <mlir/Tools/mlir-translate/MlirTranslateMain.h>
#include <mlir/Tools/mlir-translate/Translation.h>

#include <parquet/file_reader.h>

#include <pg_query.h>

#include "columnar/Catalog.h"
#include "columnar/Columnar.h"
#include "columnar/SQLParser.h"
#include "columnar/parquet/ParquetToCatalog.h"
#include "pg_query.pb.h"

namespace {

llvm::cl::opt<std::string>
    dataDir("data", llvm::cl::desc("Directory containing queryable files"),
            llvm::cl::value_desc("path to directory"));

/** Handles memory management and error conversion of the
 * \c pg_query_parse_protobuf API. */
class PgQueryParseProtobufWrapper {
private:
  PgQueryProtobufParseResult _res;

  PgQueryParseProtobufWrapper(PgQueryProtobufParseResult res) : _res(res) {}

public:
  ~PgQueryParseProtobufWrapper() { pg_query_free_protobuf_parse_result(_res); }

  static PgQueryParseProtobufWrapper parse(const char *query) {
    return PgQueryParseProtobufWrapper(pg_query_parse_protobuf(query));
  }

  llvm::Error takeError() const {
    if (_res.error) {
      // TODO: include line and column numbers.
      llvm::Twine msg(_res.error->message);
      return llvm::createStringError(llvm::inconvertibleErrorCode(), msg);
    } else {
      return llvm::Error::success();
    }
  }

  PgQueryProtobuf parseTree() const {
    assert(!_res.error);
    return _res.parse_tree;
  }
};

} // namespace

static llvm::Expected<pg_query::ParseResult>
parseSQLToProto(const char *query) {
  auto result = PgQueryParseProtobufWrapper::parse(query);
  if (auto err = result.takeError()) {
    return err;
  }

  pg_query::ParseResult proto;
  if (!proto.ParseFromArray(result.parseTree().data, result.parseTree().len)) {
    llvm_unreachable("Cannot re-parse proto generated by pg_query");
  }

  return proto;
}

static mlir::LogicalResult loadDataDir(mlir::MLIRContext *ctx,
                                       mlir::Location loc,
                                       columnar::Catalog &catalog) {
  std::filesystem::path dataDirPath(dataDir.getValue());
  if (!std::filesystem::exists(dataDirPath)) {
    return mlir::emitError(loc)
           << "Data directory '" << dataDir << "' does not exist\n";
  }

  if (!std::filesystem::is_directory(dataDirPath)) {
    return mlir::emitError(loc)
           << "Data directory '" << dataDir << "' is not a directory\n";
  }

  for (const auto &entry : std::filesystem::directory_iterator(dataDirPath)) {
    if (entry.is_regular_file() && entry.path().extension() == ".parquet") {
      try {
        auto reader = parquet::ParquetFileReader::OpenFile(entry.path());
        auto meta = reader->metadata();
        const auto &schema = *meta->schema();
        columnar::parquet::addToCatalog(ctx, catalog, entry.path().string(),
                                        schema);
      } catch (const std::exception &e) {
        mlir::emitWarning(loc) << "Failed to add parquet file to catalog: '"
                               << entry.path() << "': " << e.what();
      }
    }
  }

  return mlir::success();
}

static mlir::OwningOpRef<mlir::ModuleOp>
translateSQLToColumnar(llvm::SourceMgr &sourceMgr, mlir::MLIRContext *ctx) {
  ctx->getOrLoadDialect<columnar::ColumnarDialect>();

  auto *sourceBuf = sourceMgr.getMemoryBuffer(sourceMgr.getMainFileID());
  auto loc = mlir::FileLineColLoc::get(ctx, sourceBuf->getBufferIdentifier(),
                                       /*line=*/1, /*column=*/0);

  // Check syntax errors.
  auto proto = parseSQLToProto(sourceBuf->getBufferStart());
  if (auto err = proto.takeError()) {
    mlir::emitError(loc) << "SQL parse error: "
                         << llvm::toString(std::move(err));
    return nullptr;
  }

  // Load catalog from parquet files.
  columnar::Catalog catalog;
  if (!dataDir.empty()) {
    if (mlir::failed(loadDataDir(ctx, loc, catalog))) {
      return nullptr;
    }
  }

  // Parse SQL to Columnar IR.
  return columnar::SQLParser::parseQuery(ctx, loc, *proto, catalog);
}

int main(int argc, char *argv[]) {
  mlir::TranslateToMLIRRegistration importSQL(
      "import-sql", "Import SQL to Columnar IR", translateSQLToColumnar);
  return failed(
      mlir::mlirTranslateMain(argc, argv, "Translates SQL to columnar IR"));
}
